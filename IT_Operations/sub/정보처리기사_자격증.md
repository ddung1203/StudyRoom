# 정보처리기사 자격증

# **컴퓨터의 구성 요소**

- 프로세서: 메모리로부터 명령어를 받아와 기계어로 변환 (CU)하고 연산 (ALU)을 수행한다.
- 메모리: 명령어 및 데이터가 적재되는 공간이다.
- 입출력 장치: 데이터를 입력/출력하기 위한 컴퓨터의 외부 장치이다.

# **프로세서의 동작 과정**

- 제어 유닛 (Control Unit): 메모리로부터 명령어를 얻어 기계어로 (CPU에 정의된 일련의 명령어 집합, RISC/CISC) 변환한 후 만들어 ALU에게 전달한다.
- 레지스터: 명령어 주소, 코드, 데이터를 임시로 저장한다.
- 산술/논리 연산 장치 (Arithmetic/Logic Unit): 제어 유닛으로 부터 전달받은 명령어를 바탕으로 사칙연산, 논리합, 논리곱 등의 연산을 수행하고 결과 값을 제어 유닛에게 전달한다.

# **고급 언어, 어셈블리어, 기계어**

- 고급 언어: C, JAVA, Python과 같은 일반적인 프로그래밍 언어를 고급 언어라 한다. 고급 언어를 컴파일러가 어셈블리어로 변환한다.
- 어셈블리어: 기계 사고 방식의 언어다. 어셈블리어를 어셈블러가 기계어로 변환한다.
- 기계어: 컴퓨터가 이해할 수 있는 비트의 집합이다. 즉, CPU가 명령을 처리할 때 사용하는 언어로 2집법으로 구성된다.

# **32비트 CPU와 64 비트 CPU**

프로그램 실행을 요청받은 CPU가 한번에 처리할 수 있는 메모리의 크기이다. 즉, 32비트 CPU는 주어진 데이터를 32비트씩 잘라서 수행하고, 64비트 CPU는 64비트씩 잘라서 수행한다. 한번에 수행하는 데이터가 많을수록 데이터 입출력이 줄고 연산이 빨라지기 때문에 64비트 CPU가 훨씬 빠르다.

# **프로그램 실행 순서**

1. 사용자가 운영체제에게 프로그램 실행을 요청한다.
2. 운영체제는 프로그램의 정보를 HDD로 부터 읽어 할당된 메인 메모리 (code, data, stack, heap)에 적재한다.
3. CPU는 메인메모리에서 읽어온 정보를 바탕으로 차례로 코드를 실행한다.

# **메인 메모리의 영역 (code, data, stack, heap)**

프로그램이 실행되면 운영체제는 메인 메모리에 실행에 필요한 메모리 공간을 할당해준다. 이 메모리 공간은 크게 4가지 영역으로 나뉜다.

- **코드 영역**: 프로그램의 **소스 코드**가 저장되는 영역이다. CPU는 코드 영역에 저장된 명령어 (소스, 함수, 제어문)를 가져와서 처리한다.
- **데이터 영역**: **전역 변수와 정적 변수**가 저장되는 영역이다. 프로그램 시작과 함께 할당되며, 프로그램이 종료되면 소멸한다.
- **스택 영역**: 프로그램이 사용하는 임시 메모리 영역이며 함수의 호출과 관계되는 **지역 변수와 매개 변수**가 저장되는 영역이다. 함수의 호출과 함께 할당되며, 함수가 종료되면 소멸한다. 함수의 호출 구조가 스택 자료 구조 (LIFO)와 동일하기에 스택으로 구현된다. 컴파일 타임에 영역의 크기가 결정된다.
- **힙 영역**: 사용자에 의해 메모리 공간이 **동적으로 할당**되고 해제되는 영역이다. 즉, 동적 할당을 통해 생성된 동적 변수를 관리하기 위한 영역이다. 런타임에 영역의 크기가 결정된다.

힙 영역과 스택 영역은 사실 같은 공간을 공유한다. 힙이 메모리 위쪽 주소부터 할당되면 스택은 아래쪽부터 할당되는 식이다. 그래서 각 영역이 상대 공간을 침범하는 일이 발생할 수 있는데 이를 각각 **힙 오버플로우**, **스택 오버플로우**라 한다.

# **Compile과 Interpret**

Compile과 Interpret은 소스 코드를 변환하고 실행시키는 방식을 말한다.

- **Compile**: **소스 코드가 runtime되기 전**에 기계어로 한번에 변환 및 해석되는 방식이다. 그렇기 때문에 소스 코드에 문제가 있다면 실행되지 않고 오류를 알린다. 기존 코드는 원시 코드, 변환된 코드를 object code라 한다. 대표적인 compile 언어는 C/C++, JAVA가 있다.
- **Interpret**: **소스 코드가 먼저 runtime 된 후**에 코드 한 줄씩 변환 및 해석되는 방식이다. 그렇기 때문에 소스 코드에 문제가 있더라도 그 코드 전까지는 실행된 후, 오류를 알린다. 가상머신 위에서 컴파일되기에 소스 코드의 이동이 자유롭다. 대표적인 interpret 언어는 python이다.

# **자료형의 종류와 크기**

자료형에 대한 정보가 미리 정의되어 있으므로 자료형의 이름을 통해 메모리 공간을 할당할 수 있다. 이는 효율적인 메모리 공간 사용을 보장한다.

1. **char**
- 문자형
- 1 byte (8bit)
- 표현 범위: -128 ~ 127

2. **short**

- 정수형
- 2 byte (16bit)
- 표현 범위: -32,768 ~ 32,767

3. **int**

- 정수형
- 4 byte (32bit)
- 포현 범위: -2,147,483,648 ~ 2,147,483,647

4. **float**

- 실수형
- 4 byte (32bit)

4. **long**

- 실수형
- 4 byte (32bit)

5. **double**

- 실수형
- 8 byte (64bit)

정수형의 **표현 범위**보다 큰 수를 사용하려 할 때 **오버플로우**가 발생하며 작은 수를 사용하려 할 때를 **언더플로우**가 발생한다. unsigned 명령을 통해 양수 범위만 사용할 수 있다.

# **자료구조 — 스택, 큐, 트리, 힙**

- **스택**: 원소들의 삽입과 삭제가 리스트의 한쪽 끝에서만 수행되는 자료구조이다. **후입선출**, LIFO 방식을 따른다.

![https://miro.medium.com/max/1400/1*B6e4DBV9YSx_Pei_c3N45w.png](https://miro.medium.com/max/1400/1*B6e4DBV9YSx_Pei_c3N45w.png)

- **큐**: 리스트의 한쪽 끝에서는 원소들이 삭제되고, 반대쪽 끝에서는 삽입만 가능하게 만든 순서화된 자료구조이다. **선입선출**, FIFO 방식을 따른다. 원소 값 삭제가 발생하면 리스트 내의 모든 원소가 한칸씩 앞으로 이동하여야 하므로 연산이 오래 걸린다.

![https://miro.medium.com/max/1400/1*AJfgxfavVjiyTsozqqApMw.png](https://miro.medium.com/max/1400/1*AJfgxfavVjiyTsozqqApMw.png)

- **힙**: 이진 트리의 일종으로 최대 힙 트리, 최소 힙 트리로 나뉜다. 최대 힙은 최대 값을 루트로 하여 부모 노드의 값이 항상 자식 노드의 값보다 큰 트리 구조이며, 최소 힙은 최소 값을 루트로 하여 부모 노드의 값이 항상 자식 노드의 값보다 작은 트리 구조다.

![https://miro.medium.com/max/1400/1*lkrk6gtrr9nYnd5WkLsPwg.png](https://miro.medium.com/max/1400/1*lkrk6gtrr9nYnd5WkLsPwg.png)

최대 힙 트리와 최소 힙 트리

- **트리**: 하나의 뿌리에서 가지로 나뉘어 데이터가 저장됨으로서 계층 구조를 갖는 자료구조이다.

# **트리 순회**

1. **중위 순회** (In-order Traversal) : 왼쪽 자식, **루트**, 오른쪽 자식 순서로 방문하는 순회 방법이다. 이진 탐색 트리를 중위 순회하면 정렬된 결과를 얻을 수 있다.
2. **전위 순회** (Pre-order Traversal) : **루트**, 왼쪽 자식, 오른쪽 자식 순서로 방문하는 순서 방법이다.
3. **후위 순회** (Post-order Traversal) : 왼쪽 자식, 오른쪽 자식, **루트** 순서로 방문하는 순서 방법이다.
4. **레벨 순서 순회** (Level-order Traversal) : 너비 우선 순회 (**BFS**) 라고도 한다. 위의 세 가지 방법은 스택을 활용하여 구현할 수 있는 반면, 레벨 순서 순회는 큐를 활용해 구현한다.

![https://miro.medium.com/max/1400/1*4IIjmCbo2SnmA_Sy5tYQew.png](https://miro.medium.com/max/1400/1*4IIjmCbo2SnmA_Sy5tYQew.png)

# **BFS와 DFS**

정점과 간선으로 이루어진 그래프 자료구조를 탐색하는 방식이다.

- DFS (깊이 우선 탐색): 루트 노드에서 시작해서 해당 branch를 완벽하게 탐색한 후 다음 branch를 탐색하는 방법이다. 스택을 이용하여 구현한다.
- BFS (너비 우선 탐색): 루트 노드에서 시작해서 인접한 노드를 먼저 탐색하는 방법이다. 큐를 이용하여 구현한다.

# **배열 (Array)과 링크드 리스트 (Linked list)**

데이터를 나열한다는 점에서 유사해보이지만 구조적으로 큰 차이를 보인다.

- **배열**: 순차적으로 데이터가 저장되며 데이터가 저장된 물리적 주소 또한 순차적이다. 인덱스를 가지고 있기 때문에 원하는 데이터에 한번에 접근가능하지만 삽입/삭제를 위해서는 일부 배열을 밀고 당기는 위치 변경이 발생하기에 시간이 오래 걸린다.
- **링크드 리스트**: 배열과 마찬가지로 데이터가 순차적으로 저장되어 있지만 물리적 주소는 순차적이지 않을 수 있다. 그리고 인덱스가 없기 때문에 원하는 데이터에 한번에 접근이 불가능하다. 다만, 현재 데이터가 다음 데이터의 주소를 가지고 있기에 연결된 링크를 따라 원하는 데이터에 접근할 수 있다. 다음 데이터의 주소 변경만으로 데이터 삽입/삭제가 가능하다.

# **RDBMS (관계형 데이터베이스)와 NoSQL**

**1.RDBMS**

엄격하게 정해진 **스키마** (Fields, Records의 제약 조건에 대한 명세)에 따라 데이터를 저장하기에 명확한 데이터 구조를 보장하는 데이터베이스이다. 그렇기에 중복 데이터가 존재하지 않아 저장 공간을 절약할 수 있으며, 데이터 수정 (update)이 용이하다.

그리고 테이블 간의 관계를 통해서 큰 규모의 데이터를 여러 개의 테이블 (ex. user, item, buying)에 분산 저장할 수 있다. 분산 저장을 통해 보안을 철저히 하고, 테이블를 구조적으로 도식화 함으로 효율적으로 관리할 수 있다. 다만, 테이블 관계가 복잡해 질수록 JOIN이 많은 SQL 쿼리가 만들어 질 수 있다.

데이터 수정 (update)가 자주 발생하는 시스템이거나, 명확한 스키마가 중요한 경우 RDBMS가 적합하다.

**2. NoSQL**

스키마없이 유연하게 데이터를 저장/관리할 수 있는 데이터베이스이다. MongoDB가 대표적인 NoSQL이다.

데이터 중복이 허용되기에 수정 (update)을 위해서는 중복으로 저장된 데이터를 검색하여 모두 수정해야하는 번거로움이 있으며, 엄격한 스키마가 없다보니 데이터에 대한 규격화된 결과 값을 얻을 수 없다.

정확한 데이터 구조를 알지 못하거나, 데이터 수정 (update)보다는 쓰기 (write)와 읽기 (read)가 더 자주 발생하는 경우 NoSQL이 적합하다.

# **절차 지향과 객체 지향**

1. **절차 지향 프로그래밍 (Procedural Programming):** 물이 위에서 아래로 흐르는 것처럼 순차적인 처리가 중요시되는 프로그래밍 기법이며, C가 대표적인 절차 지향 프로그래밍 언어다. 컴퓨터의 처리구조와 유사해 실행속도가 빠르지만 디버깅이 어렵다.
2. **객체 지향 프로그래밍 (Object Oriented Programming):** 실제 세계를 표방하여 데이터와 절차를 하나의 덩어리로 처리하는 프로그래밍 기법이다. Java, Python, C++이 대표적인 객체 지향 프로그래밍 언어다. 객체 지향 프로그래밍은 기존에 짜여진 코드를 재사용하기 용이하며 디버깅이 쉽다. 단, 처리 속도가 느리며 설계에 많은 노하우와 시간이 필요하다. 객체 지향 프로그래밍은 아래의 네가지 특징을 가진다.
- **추상화**: 객체가 가진 공통의 속성이나 기능을 묶어 명시적인 이름을 부여하는 것을 말한다.
- **캡슐화**: 관련된 데이터와 코드를 하나로 묶은 것으로 데이터를 감추고 외부와의 상호작용은 메소드를 통하는 방법이다.
- **상속**: 이미 작성된 클래스를 이어 받아서 새로운 클래스를 생성하는 것으로, 기존 코드를 재활용하는 것을 말한다.
- **다형성 (**Polymorphism**)**: 같은 코드로 다른 행위를 하는 것을 말한다. 이를 가능케하는 것이 Overriding과 Overloading이다.

# **Overriding과 Overloading**

객체 지향 프로그래밍의 **다형성**을 지원하는 방법이다.

1. **Overriding:** 부모 클래스가 가지고 있는 메소드를 자식 클래스가 **재정의**해서 사용한다. 즉, 메소드의 이름/매개변수/반환형이 같은 상속 받은 메소드를 덮어쓰는 것으로 부모 클래스의 메소드는 무시하고 자식 클래스가 필요로하는 메소드를 추가하여 사용하는 것이다.
2. **Overloading:** 같은 이름의 메소드 (함수)를 여러개 정의하되, **매개 변수의 유형과 개수**를 달리하여 다양한 유형의 호출에 응답하는 것이다.

# **Garbage collector (GC)**

**Garbage**란 정리되지 않은 메모리, 유효하지 않은 객체의 메모리를 말한다. **GC**는 프로그램이 사용할 수 있는 메모리 용량이 부족할 때 가비지들을 메모리에서 해제하는 기능을 말한다.

int[] array = new int[3];

array[0] = 0;

array[1] = 10;

String[] array = new String[5]; # integer array가 가비지가 된다.

GC는 Garbage 객체를 판별하기 위해 **reachability**라는 개념을 사용한다. 어떤 객체에 유효한 참조의 여부에 따라 reachable/unreachable로 구별하고 unreachable 객체를 가비지로 간주한다. 이때 JAVA 대부분의 객체는 금방 unreachable 상태가 된다고 가정하고 객체를 저장하는 메모리 공간을 Yong generation과 Old generation으로 나눈다.

- Yong generation: 새롭게 생성한 객체의 대부분이 young generation에 위치한다. 대부분의 객체가 금방 unreachable 상태가 되기 때문에 매우 많은 객체가 young generation에 생성되었다가 GC를 통해 사라진다. (유효한 참조가 있는 객체는 남는다.)이 영역에서 객체가 사라질때 Minor GC가 발생한다고 말한다.
- Old generation: 접근 불가능 상태로 되지 않아 young generation에서 살아남은 객체가 old generation으로 복사된다. Minor GC만으로 확보한 메모리 공간이 부족할 때, old generation에서 GC가 실행된다. 이 영역에서 객체가 사라질 때 Major GC가 발생한다고 말한다.

GC가 동작할 때 **‘Stop-the-world’** 명령이 실행되는데 이는 GC를 실행하는 스레드를 제외한 모든 스레드들이 작업을 멈추는 것을 말한다. 그런데 실시간으로 통신이 필요한 어플리케이션임에도 GC가 수 초 동안 여러번 실행되어 어플리케이션이 멈춘다면 큰 문제가 된다. 그렇기 때문에 GC를 최소한으로 발생시켜 최대한의 효과를 내는 것이 중요하다.

# **Reference Counting**

Python의 주요 garbage collection mechanism은 reference counts 방식이다. Python은 모든 변수와 함수를 객체로 생성하며 만들 때마다 유형 (list, dict 또는 function)과 reference count가 생성된다.

객체의 reference count는 객체가 참조될 때 증가하고 객체의 참조가 해제될 때 감소한다. 객체의 reference count가 0이 되면 객체의 메모리가 해제된다. 순환 참조 객체의 메모리 해제를 위해 garbage collector도 함께 사용한다.

# **Pointer 변수**

어떠한 변수의 주소는 해당 변수가 저장된 컴퓨터 메모리상의 주소를 의미한다. 즉, 변수 *x*에는 integer 값 10이 저장되어 있다면, 포인터 변수 **p x*에는 변수 *x*의 메모리 주소 값이 저장된다.

# **Call-by-value, Call-by-reference, Call-by-assignment**

1. call-by-value: cbv에 의한 호출 방식은 함수 호출 시 **변수의 값을 복사하여 함수의 인자**로 전달한다. 복사된 인자는 함수 내에서만 사용되는 local variable의 특성을 가진다. 즉, 함수 안에서 인자의 값이 변경되어도 외부의 변수의 값은 변경되지 않는다.
2. call-by-reference: cbr에 의한 호출 방식은 함수 호출 시 **변수의 주소값을 복사하여 함수의 인자로 전달**한다. 따라서 함수 안에서 값이 인자의 값이 변경된다면 전체 코드에서 해당 변수의 값이 변경된다.
3. call-by-assignment (python): cba에 의한 호출 방식은 **전달받는 객체에 따라 참조 방식이 결정**된다. immutable object (int, float, tuple)이 함수의 인자로 넘어갈 땐 call-by-value로 전달된다. mutable object (list, dic, set)이 함수의 인자로 넘어갈 땐 call-by-reference로 전달된다. (list, dic, set이 mutable object 인 이유는 이 객체의 크기가 아주 큰 경우 복사 참조만 된다면 메모리 공간이 낭비되기 때문이다.)

# **가상 메모리와 페이지 폴트**

1. **가상 메모리**: 프로그램 실행에 필요한 메모리 용량 전체를 ram에서 할당받는 것이 아니라, **최소한의 메모리를 ram에서 할당받아 저장하고 나머지는 HDD (가상 메모리 공간)에 저장하는 것**이다.
2. **페이지 폴트**: 가상 메모리를 사용하게 된다면 프로그램이 사용하는 페이지는 물리 메모리인 ram과 가상 메모리인 hdd에 나뉘어 저장된다. 이때, 프로그램이 **필요로 하는 페이지가 물리 메모리에 없을 경우 페이지 폴트**라 한다.
3. **요구 페이징**: 페이지 폴트가 발생하면 운영 체제가 가상 메모리에서 해당 페이지를 찾아 물리 메모리의 불필요한 페이지와의 교체를 요구한다. 그리고 이 과정 동안은 모든 스레드가 대기한다.

# **페이지 교체 알고리즘**

요구 페이징이 발생했을 때 교체할 물리 메모리의 페이지를 선정하는 알고리즘이다.

- **FIFO** (First In First Out): 물리 메모리에 적재된지 **가장 오래된 페이지**를 교체한다. 페이지의 사용 빈도를 무시하기 때문에 활발하게 사용하는 페이지가 교체될 수 있다는 문제점이 있다. 페이지가 적재된 순서를 Queue에 저장하는 방식을 사용한다.
- **LRU** (Least Recently Used): **가장 오랜 기간 사용되지 않은 페이지**를 교체한다. 많은 운영체제가 사용하는 알고리즘이다.
- **LFU** (Least Frequently Used): **참조 횟수가 가장 적은 페이지**를 교체한다. 만약 교체 대상이 여러 개일 경우에 LRU를 사용한다. LFU는 초기에 한 페이지를 집중적으로 참조하다가, 이후에 참조하지 않는 경우에 메모리에 계속 남아있을 수 있다는 문제점이 있다.
- **MFU** (Most Frequently Used): LFU와 반대로 참조 횟수가 가장 많은 페이지를 교체하는 알고리즘이다.

# **메모리 단편화 (Memory Fragmentation)**

- **내부 단편화**: 교체된 페이지의 크기가 할당된 공간의 크기보다 작은 경우 내부 단편화가 발생한다. 이는 저장 공간 낭비로 이어진다.
- **외부 단편화**: 메모리가 할당되고 해제되는 작업이 반복될 때 작은 메모리가 중간중간 존재하게 되는데, 이 때 총 메모리 공간은 충분하지만 교체된 페이지의 크기가 할당된 공간의 크기보다 큰 경우 외부 단편화가 발생한다.

# **페이징과 세그먼테이션**

메모리 단편화를 해결할 수 있는 기법이다.

- **페이징**: 페이지가 연속적인 물리 메모리 공간에 들어가야하는 제약을 해결하기 위한 방법이다. 가상 메모리는 페이지, 물리 메모리는 프레임이라는 **고정 크기**의 블록으로 나눈 후, 페이지 테이블의 매핑을 통해 1:1 대응 시킨다. 이는 외부 단편화를 해결할 수 있다. 페이지 단위를 작게하면 내부 단편화(Internal fragmentation) 역시 해결할 수 있지만 페이지에 공간을 할당한 후, 남는 공간이 적어지기 때문에 그 만큼 page mapping 과정이 증가할 수 있다.
- **세그멘테이션**: method, function, object, variables 등 프로그램의 논리적 단위를 바탕으로 **서로 다른 크기**의 블록으로 나누는 방법이다. 세그먼트들의 크기가 서로 다르기 때문에 메모리를 페이징 기법처럼 미리 분할해 둘 수 없고, 메모리에 적재될 때 빈 공간을 찾아 할당하는 사용자 관점의 가상 메모리 관리 기법이다. 각 세그먼트 별로 길이 값을 가지고 있어 내부 단편화를 해결할 수 있다.

# **프로세스와 스레드**

- **프로세스**: 운영체제로부터 프로세서, 주소 공간, 메모리과 같은 **시스템 자원을 할당받는 작업의 단위로 실행된 프로그램**을 의미한다. 프로세스는 실행될 때 운영 체제로부터 독립된 메모리 영역 (Code, Data, Stack, Heap)을 할당받으며 다른 프로세스의 자원에는 접근할 수 없다.
- **스레드**: **프로세스 내에서 동작되는 실행의 단위**로서 Stack 외에 프로세스가 할당받은 자원 (Code, Data, Heap)을 스레드끼리 공유, 이용하면서 실행된다. 하나의 프로세스가 실행되면 기본적으로 하나의 메인 스레드가 생성된다.
- **멀티 프로세스**: 하나의 프로그램을 프로세스 여러 개로 구성하여 Context switching을 통해 실행하는 것을 말한다. 하나의 프로세스에 문제가 생기더라도 다른 프로세스에 영향을 미치지 않는다.
- **멀티 스레드**: 하나의 프로그램을 한 프로세스 내에 여러 개의 스레드로 구성하여 실행하는 것을 말한다. 멀티 프로세스보단 멀티 스레드가 더 효율적인데 그 이유는 **스레드 간의 통신 비용**이 훨씬 적기 때문이다. 하지만 스레드 간의 자원 공유는 전역 변수를 이용하기에 동기화를 신경써야한다.

# **ThreadLocal**

말 그대로 스레드 내부에서 사용되는 지역변수를 말한다. 각각의 thread scope 내에서 공유되어 사용될 수 있는 값으로 다른 스레드에서 공유 변수에 접근할 시 발생할 수 있는 동시성 문제의 예방을 위해 만들어졌다.

# **Context Switching**

프로세서가 멀티 프로세싱을 구성하여 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때, **기존 프로세스의 상태 또는 레지스터 값 (context)**을 저장하고 다음 프로세스를 수행하도록 **새로운 프로세스의 상태 또는 레지스터 값**을 교체하는 작업을 Context switching이라 한다.

멀티 프로세싱을 Computer multitasking을 통해 빠른 속도로 Task를 바꿔 가며 실행하여 실시간 처리에 근사하도록 하는 기술이다.

# **교착 상태 (Deadlock) 발생 4가지 조건**

교착 상태란 서로 다른 프로세스가 **서로의 자원을 요구하며 무한정 기다리는 현상**을 말하며, 아래의 4가지 조건 중 하나라도 만족하지 않으면 교착 상태는 발생하지 않는다.

1. **상호배제** (Mutual exclusion): 한번에 한 프로세스만이 자원을 점유할 수 있다.
2. **점유대기** (Hold and wait): 프로세스가 이미 자원을 점유하는 상태에서 다른 자원을 무한정 기다린다.
3. **비선점** (No preemption): 프로세스가 어떤 자원의 점유를 끝낼 때까지 그 자원을 뺏을 수 없다.
4. **순환대기** (Circular wait): 각 프로세스들이 원형으로 구성되어 순환적으로 자원을 요구한다.

# **뮤텍스와 세마포어**

이 둘의 궁극적인 목표는 **‘다수의 프로세스나 스레드가 공유 자원에 동시에 접근하는 것을 제어하는 것’**이다.

- **뮤텍스**: 한 스레드, 프로세스에 의해 소유될 수 있는 **Key**를 기반으로 한 상호배제 기법이다. 한 스레드가 임계 영역에 들어갈 때 lock을 걸어 다른 스레드가 접근하지 못하도록 하고, 임계 영역에서 나올 때 unlock한다.
- **세마포어**: 현재 공유 자원에 접근할 수 있는 **스레드, 프로세스의 수**를 나타내는 값을 두는 상호 배제 기법이다. 그 값만큼 동시에 스레드가 해당 공유 자원에 접근할 수 있다.

# **RISC와 CISC**

프로세서가 가진 명령어 세트를 기준으로 RISC와 CISC로 나누니다.

- **RISC** (Reduce Instruction Set Computer): 핵심적인 명령어를 기반으로 **최소한의 명령어 세트를 구성한 프로세서**다. 고정적인 길이와 간단한 명령어로 빠른 동작 속도를 자랑하한다. 적은 명령어 세트를 가지고 있으므로 프로그램을 구성하는 명령어가 단순하지만 다수의 명령어를 필요로 한다.
- **CISC** (Complex Instruction Set Computer): 연산을 처리하는 **복잡한 명령어들을 수백개 이상 탑재하고 있는 프로세서**다. 명령어 길이가 다양하며 개수가 많아 프로그램의 구성이 복잡해지지만 소수의 명령어로 구현할 수 있다.

# **OSI 7 Layer**

네트워크에서 통신이 일어나는 과정을 **7단계로 캡슐화**하여 서로 다른 동작을 각 layer에서 담당하는 것을 말한다. 이로서 통신이 일어나는 과정을 단계적으로 파악할 수 있으며 layer 별로 각기 다른 동작을 수행하기에 오류 탐지가 용이하다.

1. Physical layer: 전기적, 기계적 특성을 바탕으로 **비트 흐름**을 전송한다. 이 계층은 데이터를 전달만 할 뿐, 데이터가 무엇인지 전혀 신경쓰지 않는다. (케이블, 리피터, 허브 등)
2. DataLink layer: 안전한 정보 전달을 보장한다. 물리 계층에서 전달 받은 **프레임**의 오류를 찾고 필요시 재전송을 요청한다.
3. Network layer: 오류 없는 **패킷**을 목적지까지 안전하고 빠르게 전달하는 경로 (라우팅)를 찾는 계층이다.
4. Transport layer: 전송을 통해 통신을 활성화하는 계층이다. **패킷**의 전송이 유효한지 확인하고 실패한 패킷을 재전송한다. end-to-end 통신의 신뢰성을 보장하고, 오류 검출, 흐름제어, 중복 검사를 수행한다.
5. Session layer: 그 전까진 물리적 측면의 통신이었다면 포트를 연결하여 논리적인 통신을 가능케하는 계층이다.
6. Presentation layer: 응용 프로그램을 위해 형식상 차이를 갖는 데이터를 인코딩하여 일관된 형태의 데이터를 표현하는 계층이다.
7. Application layer: 사용자와 직접 상호작용하는 계층이다. 크롬, 파이어폭스가 대표적 예시이다.

# **TCP와 UDP**

이 둘은 전송 계층에서 패킷을 보내기 위한 프로토콜이다.

- TCP (Transmission Control Protocol): **연결형 서비스**로 3-way handshaking 과정을 통해 연결을 설정하고, 4-way handshaking을 통해 해제한다. 그렇기에 높은 신뢰성과 전송 순서를 보장한다. 1:1 통신에서 사용된다. UDP보다는 속도가 느리다.
- UDP (User Datagram Protocol): **비연결형 서비스**로 패킷을 주고 받을 때 신호 절차를 거치지 않는다. 그렇기에 신뢰성이 낮으며 전송 순서가 바뀔 수 있다. 1:N 이나 N:N 통신에서 사용된다. TCP보다 속도가 빠르다.

# **3-way handshaking과 4-way handshaking (TCP)**

- 3-way handshaking: 장치들 사이의 접속을 성립하기 위한 절차로 양 장치 모두 데이터 통신 준비가 되었다는 것을 보장한다.

과정: SYN (Client) → SYN + ACK (Server) → ACK (Client)

- 4-way handshaking: 장치들 사이의 통신을 종료하기 위한 절차이다.

과정: FIN (Client) → ACK (Server) → FIN (Server) → ACK(Client)